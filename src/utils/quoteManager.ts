import { ConfiguratorState, ShadeCalculations } from '../types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;
const QUOTE_TOKENS_KEY = 'shade_configurator_quote_tokens';

export interface SavedQuote {
  id: string;
  reference: string;
  expiresAt: string;
  quoteName: string;
  customerReference?: string | null;
  nameAutoGenerated: boolean;
  accessToken: string;
  shopifyCustomerCreated?: boolean;
  shopifyCustomerId?: string | null;
}

export interface QuoteData {
  id: string;
  quote_reference: string;
  quote_name: string;
  customer_reference?: string | null;
  name_auto_generated: boolean;
  customer_email?: string;
  access_token: string;
  config_data: ConfiguratorState;
  calculations_data: ShadeCalculations;
  created_at: string;
  expires_at: string;
  status: string;
}

export interface QuoteSearchFilters {
  search?: string;
  status?: 'active' | 'expiring' | 'expired' | 'completed' | 'all' | 'saved';
  fabricType?: string;
  corners?: number;
  minPrice?: number;
  maxPrice?: number;
  startDate?: string;
  endDate?: string;
  sortBy?: 'created_at' | 'expires_at' | 'price' | 'quote_name';
  sortOrder?: 'asc' | 'desc';
  page?: number;
  pageSize?: number;
}

/**
 * Token Management Functions
 */

/**
 * Store a quote access token in localStorage
 */
export function storeQuoteToken(token: string): void {
  const tokens = getStoredQuoteTokens();
  if (!tokens.includes(token)) {
    tokens.unshift(token);
    // Keep only the most recent 50 tokens
    const limitedTokens = tokens.slice(0, 50);
    localStorage.setItem(QUOTE_TOKENS_KEY, JSON.stringify(limitedTokens));
  }
}

/**
 * Get all stored quote tokens from localStorage
 */
export function getStoredQuoteTokens(): string[] {
  try {
    const stored = localStorage.getItem(QUOTE_TOKENS_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch (error) {
    console.error('Error reading stored quote tokens:', error);
    return [];
  }
}

/**
 * Remove a quote token from localStorage
 */
export function removeQuoteToken(token: string): void {
  const tokens = getStoredQuoteTokens();
  const filtered = tokens.filter(t => t !== token);
  localStorage.setItem(QUOTE_TOKENS_KEY, JSON.stringify(filtered));
}

/**
 * Clear all stored quote tokens
 */
export function clearAllQuoteTokens(): void {
  localStorage.removeItem(QUOTE_TOKENS_KEY);
}

/**
 * Get count of stored tokens
 */
export function getStoredQuoteCount(): number {
  return getStoredQuoteTokens().length;
}

export interface QuoteSearchResult {
  quotes: QuoteData[];
  pagination: {
    page: number;
    pageSize: number;
    totalPages: number;
    totalResults: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
  stats: {
    total: number;
    active: number;
    expiring: number;
    expired: number;
    completed: number;
  };
}

/**
 * Save a quote to the database
 */
export async function saveQuote(
  config: ConfiguratorState,
  calculations: ShadeCalculations,
  email?: string,
  quoteName?: string,
  customerReference?: string
): Promise<SavedQuote> {
  const response = await fetch(`${SUPABASE_URL}/functions/v1/save-quote`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      config,
      calculations,
      email: email || null,
      quoteName: quoteName || null,
      customerReference: customerReference || null,
    }),
  });

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to save quote');
  }

  const savedQuote = {
    id: data.quote.id,
    reference: data.quote.reference,
    expiresAt: data.quote.expiresAt,
    quoteName: data.quote.quoteName,
    customerReference: data.quote.customerReference,
    nameAutoGenerated: data.quote.nameAutoGenerated,
    accessToken: data.quote.accessToken,
    shopifyCustomerCreated: data.quote.shopifyCustomerCreated,
    shopifyCustomerId: data.quote.shopifyCustomerId,
  };

  // Store the access token for future retrieval
  storeQuoteToken(savedQuote.accessToken);

  return savedQuote;
}

/**
 * Retrieve a quote by access token
 */
export async function getQuoteByToken(token: string): Promise<QuoteData> {
  const response = await fetch(
    `${SUPABASE_URL}/functions/v1/save-quote?token=${encodeURIComponent(token)}`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to retrieve quote');
  }

  return data.quote;
}

/**
 * Retrieve a quote by ID (legacy support)
 */
export async function getQuoteById(id: string): Promise<QuoteData> {
  const response = await fetch(
    `${SUPABASE_URL}/functions/v1/save-quote?id=${encodeURIComponent(id)}`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to retrieve quote');
  }

  return data.quote;
}

/**
 * Retrieve a quote by reference number
 */
export async function getQuoteByReference(reference: string): Promise<QuoteData> {
  const response = await fetch(
    `${SUPABASE_URL}/functions/v1/save-quote?reference=${encodeURIComponent(reference)}`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to retrieve quote');
  }

  return data.quote;
}

/**
 * Retrieve all quotes using stored access tokens
 */
export async function getStoredQuotes(filters: QuoteSearchFilters = {}): Promise<QuoteSearchResult> {
  const tokens = getStoredQuoteTokens();

  if (tokens.length === 0) {
    return {
      quotes: [],
      pagination: {
        page: 1,
        pageSize: 20,
        totalPages: 0,
        totalResults: 0,
        hasNextPage: false,
        hasPreviousPage: false,
      },
      stats: {
        total: 0,
        active: 0,
        expiring: 0,
        expired: 0,
        completed: 0,
      },
    };
  }

  return searchQuotes(tokens, filters);
}

/**
 * Update quote status (e.g., mark as completed)
 */
export async function updateQuoteStatus(
  id: string,
  status: 'saved' | 'completed' | 'expired'
): Promise<void> {
  const response = await fetch(`${SUPABASE_URL}/functions/v1/save-quote`, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ id, status }),
  });

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to update quote status');
  }
}

/**
 * Generate a shareable quote URL with access token
 */
export function generateQuoteUrl(quoteId: string, accessToken?: string): string {
  const baseUrl = window.location.origin;
  if (accessToken) {
    return `${baseUrl}${window.location.pathname}?quote=${quoteId}&token=${encodeURIComponent(accessToken)}`;
  }
  return `${baseUrl}${window.location.pathname}?quote=${quoteId}`;
}

/**
 * Get quote ID and token from URL if present
 */
export function getQuoteIdFromUrl(): string | null {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('quote');
}

/**
 * Get access token from URL if present
 */
export function getAccessTokenFromUrl(): string | null {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('token');
}

/**
 * Format expiration date for display
 */
export function formatExpirationDate(expiresAt: string): string {
  const date = new Date(expiresAt);
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

/**
 * Check if quote is expired
 */
export function isQuoteExpired(expiresAt: string): boolean {
  return new Date(expiresAt) < new Date();
}

/**
 * Mark quote as converted to cart
 */
export async function markQuoteConverted(quoteId: string): Promise<void> {
  const response = await fetch(`${SUPABASE_URL}/functions/v1/save-quote`, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      id: quoteId,
      status: 'completed',
    }),
  });

  if (!response.ok) {
    throw new Error('Failed to mark quote as converted');
  }

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to mark quote as converted');
  }
}

/**
 * Search and filter quotes using access tokens
 */
export async function searchQuotes(
  tokens: string[],
  filters: QuoteSearchFilters = {}
): Promise<QuoteSearchResult> {
  const params = new URLSearchParams();
  params.append('tokens', tokens.join(','));

  if (filters.search) params.append('search', filters.search);
  if (filters.status) params.append('status', filters.status);
  if (filters.fabricType) params.append('fabricType', filters.fabricType);
  if (filters.corners) params.append('corners', filters.corners.toString());
  if (filters.minPrice) params.append('minPrice', filters.minPrice.toString());
  if (filters.maxPrice) params.append('maxPrice', filters.maxPrice.toString());
  if (filters.startDate) params.append('startDate', filters.startDate);
  if (filters.endDate) params.append('endDate', filters.endDate);
  if (filters.sortBy) params.append('sortBy', filters.sortBy);
  if (filters.sortOrder) params.append('sortOrder', filters.sortOrder);
  if (filters.page) params.append('page', filters.page.toString());
  if (filters.pageSize) params.append('pageSize', filters.pageSize.toString());

  const response = await fetch(
    `${SUPABASE_URL}/functions/v1/search-quotes?${params.toString()}`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to search quotes');
  }

  return {
    quotes: data.quotes,
    pagination: data.pagination,
    stats: data.stats,
  };
}
